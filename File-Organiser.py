# Importign nexessary modules
import os           # OS (checking directories)
import shutil       # File Operation
import re           # Regex
import csv          # CSV operations 
import threading    # Threading
import time         # Time

# TODO : Automatic Beta Test with real data - Real Application (with auto launch, and actual data)


# Original Path to check where for new files
# Input directory for sorting files
startPATH = r"H:\hjgre\Downloads2\DropSort"
automaticInterval = 6
inpMsg = "Auto-File-Organizer : Command: (h for help): "

# Stores all routes in a list of dictionaries. to be searched when creating final destination path for a file.
routes = []

# Create Dictionary of available routes.
def readCSV():
    # Read all the codes into a dictionary.
    with open("./Routes.csv", mode='r') as file:
        reader = csv.DictReader(file)

        # Add each dictionary to the routes list.
        for row in reader:
            routes.append(row)

# Detects any changes to the given PATH (startPATH) and returns a list of all the changed files to be sorted.
def detectChange(path):
    allFiles = os.listdir(path) # Gets all files in the path in a list

    # Clean list
    if "Overflow" in allFiles:
        allFiles.remove("Overflow")
    if "Games" in allFiles:
        allFiles.remove("Games")
    
    return allFiles

# Handles the actual moving of the file from one location to another.
def moveFile(file, newPath):
    # Create original and new path based of parameters.
    oldPath = startPATH + "/" + file
    newPath = newPath + "/" + file

    # Using module to handle physical file move.
    shutil.move(oldPath, newPath)
    
    # Return (*to be implemented when securing the program)
    return 

# Route the file to correct destination - finds all the codes then finds the path based of the codes.
# Obtains code abreviations from filename.
def obtainCodes(fileName):
    # Remove FileType - mask finds the final full stop and looks ahead to the end of the string.
    mask = r"^(.*)(?=\.[^.]*$)"
    regex_name = re.findall(mask, fileName)
    # If it is a directory will not have a file type so nothing will be picked up in mask. Therefore no change.
    if len(regex_name) != 0:
        fileName = regex_name[0]


    # Obtain Code - Between the last '_' and the end of the string.
    mask = r"\_[^_]*$"
    fileName = re.findall(mask, fileName)   
    fileName = fileName[0] # Select first item in list (findall returns list) - findall Returns list.

    fileName = fileName[1:] # Remove the _ from the string.

    # Split codes into seperate code in a list (splitting on '-')
    mask = r"[^-]+"

    codes = re.findall(mask, fileName)
    return codes    # Returns list generated by findall

# Processes the codes - finds destination PATH & checks if filename needs cleaning.
def findDestination(codes, routes, filename):
    # Loop over codes and check if valid code and find path

    # Base Case - if no valid code, move the file to the overflow area for manual processing. 
    # Provided user hasn't changed routes format, this should be the first dict in route therefore â„¦(1) as it is first.
    for route in routes:
        if route['code'] == "XX":
            destination = route['path']
            break

    # Find if there is a valid base path
    # Check each dictionary in list and see if the code is the same as in the dictionary. (if it is set the destination to destination in the dictionary.)
    for route in routes:
        if route['code'] == codes[0]:
            destination = route['path']

            # Check for further extentions - using same process as for base path but if it finds a valid extention, concatenated the path.
            # Skips the first code (used as a base path, and if the code is 'rm' as not a code path)
            # TODO : Make more efficient (seperate CSV) - this will ensure it is a valid extension?
            for index, code in enumerate(codes):
                if index == 0 or code == "rm":
                    continue
                for route in routes:
                    if route['code'] == code:
                        destination += route['path']
                    
                    break # Limits Processing once code is found 

            break # To limit processing, if the code is found it shouldn't be repeated in routes so break.

    # If rm is present then the filename needs to be cleaned (ie codes removed)
    if "rm" in codes:
        filename = cleanName(filename)
        return destination, filename, True
    
    # Returns: destination PATH, filename the file should be saved as & if cleanName has been used
    return destination,filename, False

# Cleans File Name.
def cleanName(fileName):
    # Locates the codes between final '_' and the file type 
    mask = r"(_[^_]+)(?=\.[^.]*$)"

    match = re.search(mask, fileName)

    # If codes are found then it is a file and codes should be replaced with "" 
    if match:
        fileName = fileName.replace(match[0], "")
        return fileName
    
    # For handling directorys
    # Ensure it is not a file by checking for a filetype (breaks if full-stop in name)
    mask = r"^(.*)(?=\.[^.]*$)"
    regex_name = re.findall(mask, fileName)
    # If it is a directory will not have a file type so nothing will be picked up in mask.
    if len(regex_name) == 0:
        # Code will be at end after last '_' to the end of the file so remove it
        mask = r"(_[^_]+)$"
        reg = re.findall(mask, fileName)
        fileName = fileName.replace(reg[0], "")
        return fileName
    
    # If provblem occured and nothing is changed than just return the original filename. 
    return fileName

# Runs the full process of finding files to sort, sorting them & renaming them.
def main():
    # Make sure using most-up-to-date routes (ie re-read)
    readCSV()

    # Find a list of files that need to be sorted
    files = detectChange(startPATH)

    # Iterate over each file, locate the codes and subsequent destination 
    for file in files:
        codes = obtainCodes(file)
        returns = findDestination(codes, routes, file)
        destination = returns[0]; filename = returns[1]; isNameChange = returns[2]

        # Move file to new location
        moveFile(file,destination)

        # Change the name if necessary
        if isNameChange:
            try:
                os.rename((destination + "/" + file), (destination+ "/" + filename))
            except Exception as e:
                print(f"File name has not been cleaned but may still have been relocated: Error Msg: {e}")

    
    print("\r\033[KFiles Processed")


# THREADING to run the process yet allowing the user to dictate when to stop it etc.

# Used to stop automatic processing and allow the program to sync.
stop_thread = True


# Used to start the process running automatically every interval (original 10mins).
def automaticRun():
    global stop_thread, automaticInterval      # Ensure edits global scope.
    # While the process has not been stopped by user (will be running in a seperate thread)
    while not stop_thread:
        main()
        # If the stop_thread is set to True this time will run out and the procedure will exit out after timer.
        #automaticInterval = automaticInterval / 100
        for i in range(1):
            if not stop_thread:
                time.sleep(automaticInterval) # Wait 10mins
            else:
                break

auto = threading.Thread(target=automaticRun)
# Starts the automatic process on a seperate thread.
def startAutomatic():
    global stop_thread, auto
    stop_thread = False     # Ensure processing does not stop instantly.
    # Creating a new thread that will run the automatic processing. 
    auto = threading.Thread(target=automaticRun)
    auto.start()            # Start the processing on the seperate thread.

# Stops the automatic process.
def stopAutomatic():
    global stop_thread, auto
    stop_thread = True      # This will stop the automatic processing loop.
    auto.join()             # Syncs the program/thread (thread merges & joins main program when finishes)

# Get command for user for next step.
def userInput():
    global auto

    while True:
        # Gain the user's command.
        startupInput = input(inpMsg) 

        if startupInput == "h":   # Output Commands to user to assist with all available commands. 
            print("""Commands: h = help menu giving available commands
            a = start automatic processing.
            s = stops automatic processing.
            m = begin a manual process (stops automatic).
            c = create new route/extension.
            q = quit program.""")

        elif startupInput == "a": # Starts automatic processing.
            if not auto.is_alive():
                print("Type 's' to stop.")
                startAutomatic()
            else:
                print("Already Running")

        elif startupInput == "m": # Switches to manual processing (and does a manual run).
            main()
            if auto.is_alive():
                stopAutomatic()

        elif startupInput == "s": # Stops the automatic process (without quitting program)
            if auto.is_alive():
                print("Stopping Automatic Process...")
                stopAutomatic()
                print("Automatic Process has been stopped")
            else:
                print("Process is not running")

        elif startupInput == "c": # Creates a new route for the program
            # Gains necessary input to create a new path.
            code = input("What is the code for the new route? ")
            desc = input("Give a short description for the path: ")
            path = input("What is the full path to the destination directory for the route?")
            type = input("What is the type of the route (base or extention)? ")

            if code == "" or path == "" or type =="":
                print("Missing Necessary Data")
                continue

            # Check if code is a copy
            dup = False
            readCSV()

            for route in routes:
                if route['code'] == code:
                    print("Duplicate Code")
                    dup = True
                    break
            
            if dup:
                continue

            if type == "base":
                # Check base directory is valid.
                if not os.path.exists(path):
                    print("Not a valid PATH")
                    continue
            elif type == "extention":
                base = input("Give the full base path of the extention directory for the extention: ")
                # Check the extention path is valid.
                if not os.path.exists(base):
                    print("Not a valid PATH")
                    continue

                else:
                    path = path.replace(base, "")   # Create a valid extention path.
            else:
                print("Please correctly type 'base' or 'extention'.")
                continue

            # *NOTE : DW if string writes without "" shouldn't break it. 

            # Write the new Route to the csv.
            with open('./Routes.csv', mode='a', newline='') as file:
                writer = csv.writer(file)
                writer.writerow([code, path, desc, type])
            
            userInput()
            return
        
        elif startupInput == "q": # Quit Application

            # If the automatic process thread is going, then stop it and quit application.
            if auto.is_alive():
                stopAutomatic()
                print("Quitting automatic process.")
            print("Quitting Application")
            return
        
        else:
            continue

# Upon Starting program start by prompting user on what processsing mode they want to use.
userInput()