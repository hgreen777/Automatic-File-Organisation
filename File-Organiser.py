# Importign nexessary modules
import os           # OS (checking directories)
import shutil       # File Operation
import re           # Regex
import csv          # CSV operations 
import threading    # Threading
import time         # Time

# TODO : (Potential use binary tree to make searching for routes more efficient - cant guarentee balanced - personal use is balanced due to me maintaining?), External extentions file - ~Line: 100

# TODO : Ensure break on line 111 does not break the program (tries to make it more efficient by limiting processing)

# TODO : Creating new locations from CLI input - Test

# TODO : Manually Run Command (from CLI) - Test - test that a user cannot try starting automatic processing twice

# TODO : Automatic Running - Test

# Original Path to check where for new files
# Input directory for sorting files
startPATH = r"H:\hjgre\Downloads2\DropSort"
automaticInterval = 600

# Stores all routes in a list of dictionaries. to be searched when creating final destination path for a file.
routes = []

# Create Dictionary of available routes
def readCSV():
    # Read all the codes into a dictionary.
    with open("./Routes.csv", mode='r') as file:
        reader = csv.DictReader(file)

        # Add each dictionary to the routes list.
        for row in reader:
            routes.append(row)

# Detects any changes to the given PATH (startPATH) and returns a list of all the changed files to be sorted.
def detectChange(path):
    allFiles = os.listdir(path) # Gets all files in the path in a list

    # Clean list
    if "Overflow" in allFiles:
        allFiles.remove("Overflow")
    if "Games" in allFiles:
        allFiles.remove("Games")
    
    return allFiles


# Handles the actual moving of the file from one location to another.
def moveFile(file, newPath):
    # Create original and new path based of parameters.
    oldPath = startPATH + "/" + file
    newPath = newPath + "/" + file

    # Using module to handle physical file move.
    shutil.move(oldPath, newPath)
    
    # Return (*to be implemented when securing the program)
    return 

# Route the file to correct destination - finds all the codes then finds the path based of the codes.
# Obtains code abreviations from filename
def obtainCodes(fileName):
    # Remove FileType - mask finds the final full stop and looks ahead to the end of the string.
    mask = r"^(.*)(?=\.[^.]*$)"
    regex_name = re.findall(mask, fileName)
    # If it is a directory will not have a file type so nothing will be picked up in mask. Therefore no change.
    if len(regex_name) != 0:
        fileName = regex_name[0]


    # Obtain Code - Between the last '_' and the end of the string.
    mask = r"\_[^_]*$"
    fileName = re.findall(mask, fileName)   
    fileName = fileName[0] # Select first item in list (findall returns list) - findall Returns list.

    fileName = fileName[1:] # Remove the _ from the string.

    # Split codes into seperate code in a list (splitting on '-')
    mask = r"[^-]+"

    codes = re.findall(mask, fileName)
    return codes    # Returns list generated by findall

# Processes the codes - finds destination PATH & checks if filename needs cleaning.
def findDestination(codes, routes, filename):
    # Loop over codes and check if valid code and find path

    # Base Case - if no valid code, move the file to the overflow area for manual processing. 
    # Provided user hasn't changed routes format, this should be the first dict in route therefore â„¦(1) as it is first.
    for route in routes:
        if route['code'] == "XX":
            destination = route['path']
            break

    # Find if there is a valid base path
    # Check each dictionary in list and see if the code is the same as in the dictionary. (if it is set the destination to destination in the dictionary.)
    for route in routes:
        if route['code'] == codes[0]:
            destination = route['path']

            # Check for further extentions - using same process as for base path but if it finds a valid extention, concatenated the path.
            # Skips the first code (used as a base path, and if the code is 'rm' as not a code path)
            # TODO : Make more efficient (seperate CSV) - this will ensure it is a valid extension?
            for index, code in enumerate(codes):
                if index == 0 or code == "rm":
                    continue
                for route in routes:
                    if route['code'] == code:
                        destination += route['path']
                    
                    break # Limits Processing once code is found 

            break # To limit processing, if the code is found it shouldn't be repeated in routes so break.

    # If rm is present then the filename needs to be cleaned (ie codes removed)
    if "rm" in codes:
        filename = cleanName(filename)
        return destination, filename, True
    
    # Returns: destination PATH, filename the file should be saved as & if cleanName has been used
    return destination,filename, False

# Cleans File Name
def cleanName(fileName):
    # Locates the codes between final '_' and the file type 
    mask = r"(_[^_]+)(?=\.[^.]*$)"

    match = re.search(mask, fileName)

    # If codes are found then it is a file and codes should be replaced with "" 
    if match:
        fileName = fileName.replace(match[0], "")
        return fileName
    
    # For handling directorys
    # Ensure it is not a file by checking for a filetype (breaks if full-stop in name)
    mask = r"^(.*)(?=\.[^.]*$)"
    regex_name = re.findall(mask, fileName)
    # If it is a directory will not have a file type so nothing will be picked up in mask.
    if len(regex_name) == 0:
        # Code will be at end after last '_' to the end of the file so remove it
        mask = r"(_[^_]+)$"
        reg = re.findall(mask, fileName)
        fileName = fileName.replace(reg[0], "")
        return fileName
    
    # If provblem occured and nothing is changed than just return the original filename. 
    return fileName

# Runs the full process of finding files to sort, sorting them & renaming them
def main():
    # Make sure using most-up-to-date routes (ie re-read)
    readCSV()

    # Find a list of files that need to be sorted
    files = detectChange(startPATH)

    # Iterate over each file, locate the codes and subsequent destination 
    for file in files:
        codes = obtainCodes(file)
        returns = findDestination(codes, routes, file)
        destination = returns[0]; filename = returns[1]; isNameChange = returns[2]

        # Move file to new location
        moveFile(file,destination)

        # Change the name if necessary
        if isNameChange:
            try:
                os.rename((destination + "/" + file), (destination+ "/" + filename))
            except Exception as e:
                print(f"File name has not been cleaned but may still have been relocated: Error Msg: {e}")

    
    print("Files Processed")

# THREADING to run the process yet allowing the user to dictate when to stop it etc.

# Used to stop automatic processing and allow the program to sync.
stop_thread = False

# Used to start the process running automatically every interval (original 10mins)
def automaticRun():
    global stop_thread      # Ensure edits global scope.
    # While the process has not been stopped by user (will be running in a seperate thread)
    while not stop_thread:
        main()
        # If the stop_thread is set to True this time will run out and the procedure will exit out after timer.
        time.sleep(automaticInterval) # Wait 10mins

# Creating a new thread that will run the automatic processing. 
auto = threading.Thread(target=automaticRun)

# Starts the automatic process on a seperate thread
def startAutomatic():
    global stop_thread, auto
    stop_thread = False     # Ensure processing does not stop instantly.
    auto.start()            # Start the processing on the seperate thread.

# Stops the automatic process 
def stopAutomatic():
    global stop_thread, auto
    stop_thread = True      # This will stop the automatic processing loop.
    auto.join()             # Syncs the program/thread (thread merges & joins main program when finishes)

def userInput():
    # Gain the user's command.
    startupInput = input("Auto-File-Organizer : Command: (h for help): ") 

    if startupInput == "h":   # Output Commands to user to assist with all available commands. 
        print("""Commands: h = help menu giving available commands
          a = start automatic processing.
          s = stops automatic processing.
          m = begin a manual process (stops automatic).
          c = create new route/extension.
          q = quit program.""")
    elif startupInput == "a": # Starts automatic processing.
        startAutomatic()
    elif startupInput == "m": # Switches to manual processing (and does a manual run).
        main()
        if auto.is_alive():
            stopAutomatic()
    elif startupInput == "c": # Creates a new route for the program
        # Gains necessary input to create a new path.
        code = input("What is the code for the new route? ")
        desc = input("Give a short description for the path: ")
        path = input("What is the full path to the destination directory for the route?")
        type = input("What is the type of the route (base or extention)? ")

        # TODO : Comment from here
        if type == "base":
            # Check directory
            if os.path.exists(path) == False:
                print("Not a valid PATH")
                userInput()
        if type == "extention":
            base = input("Give the path of the base directory for the extention: ")
            if os.path.exists(base) == False:
                print("Not a valid PATH")
                userInput()
            else:
                path = path.replace(base, "")

        with open('./Routes.csv', mode='a', newline='') as file:
            writer = csv.writer(file)
            # Write a row with the route information
            writer.writerow([code, desc, path, type])

        
    elif startupInput == "q":
        if auto.is_alive():
            stopAutomatic()
            print("Quitting automatic process.")
        print("Quitting Application")
        return
    
    # If a process has started give the user the option to give another command (ie stop the processing)
    userInput()

# Upon Starting program start by prompting user on what processsing mode they want to use.
userInput()